	<!DOCTYPE HTML>
	<html>
	<head>

	  <meta charset="utf-8">
	  <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.91/jsxgraphcore.js"></script>
	  <script src = "d3.min.js"></script>
	  <script type="text/javascript"
			src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
			</script>
			<link rel="stylesheet" type="text/css" href="http://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css" />
			<script type="text/javascript"
			src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
			</script>
	  <script src="http://d3js.org/d3.v3.min.js"></script>
	  <style>

		   .node circle {
			   fill: #fff;
			   stroke: steelblue;
			   stroke-width: 3px;
		   }

		   .node text { font: 12px sans-serif; }

		   .link {
			   fill: none;
			   stroke: #ccc;
			   stroke-width: 2px;
		   }
	   </style>

	</head>
	<body>
			<div>
		</div>
	<form>
	<FONT COLOR = "#0000FF"> <h3>Сonstruction of the tree using the regular expression</FONT></h3>
	Allowable symbols: \(1-9, a-z, A-Z, +, -, *, /,\)^\(, (, )\)<br><br>
	Enter expression: <input type="text" id="odeinput" value=""><input type=button value="ok" onclick="doIt()">
	</form>
	<textarea id="area" style="width:350px; height:40px;"></textarea>
	<textarea id="area2" style="width:350px; height:40px;"></textarea>
		<br>
		<div>
		<br>



	<br>
		</div> 
	<script>

	//var brd = JXG.JSXGraph.initBoard('box', {axis:true, boundingbox:[-11,11,11,-11]});

	function doIt() {
	  var text = document.getElementById("odeinput").value;
	  var area=document.getElementById("area");
	  //var area2=document.getElementById("area2");
	  
	  area.value=text;
	  
	  var text_correct = true;
	  var bracket_num = 0;

		   //Проверка
			for (var i = 0; i < text.length; i++) {
			if (text[i] >= '0' && text[i] <= '9' || text[i] >= 'a' && text[i] <= 'z' || text[i] >= 'A' && text[i] <= 'Z' || text[i] == '+' || text[i] == '-' || text[i] == '*' || text[i] == '/' || text[i] == '^' || text[i] == '(' || text[i] == ')') {
			}
			else {
				text = "TEXT INCLUDES INCORRECT SYMBOLS";
				area.value=text;
				text_correct = false;
				break;
			}
			
			 if (((text[i]=='+')||(text[i]=='-')||(text[i]=='/')||(text[i]=='*')||(text[i]=='^'))&& ((text[i+1]=='+')||(text[i+1]=='-')||(text[i+1]=='/')||(text[i+1]=='*')||(text[i+1]=='^'))) {
				text = "WRITING MATH SYMBOLS IS INCORRECT";
				area.value=text;
				text_correct = false;
				break;
			 }
			 if ((text[i] >= 'a' && text[i] <= 'z' || text[i] >= 'A' && text[i] <= 'Z')&&(text[i+1] >= 'a' && text[i+1] <= 'z' || text[i+1] >= 'A' && text[i+1] <= 'Z')) {
				text = "WRITING SYMBOLS IS INCORRECT";
				area.value=text;
				text_correct = false;
				break;
			}
			if ((text[i] >= '0' && text[i] <= '9')&&(text[i+1] >= 'a' && text[i+1] <= 'z' || text[i+1] >= 'A' && text[i+1] <= 'Z')) {
				text = "WRITING SYMBOLS AND MATH SYMBOLS IS INCORRECT";
				area.value=text;
				text_correct = false;
				break;
			}
			if ((text[i] >= 'a' && text[i] <= 'z' || text[i] >= 'A' && text[i] <= 'Z' )&&(text[i+1] >= '0' && text[i+1] <= '9')) {
				text = "WRITING SYMBOLS AND MATH SYMBOLS IS INCORRECT";
				area.value=text;
				text_correct = false;
				break;
			}
			///////////////////////////////
			 if (text[i] == '(') {
				bracket_num++;
				 if (text[i + 1] == ')') {
					text = "BRACKETS ARE INCORRECT";
					area.value=text;
					text_correct = false;
					break;
				}
			 }
			if (text[i] == ')')
				bracket_num--;

			}
			if ((text[0]=='+')||(text[0]=='-')||(text[0]=='/')||(text[0]=='*')||(text[0]=='^')||
			(text[text.length-1]=='+')||(text[text.length-1]=='-')||(text[text.length-1]=='/')||(text[text.length-1]=='*')||(text[text.length-1]=='^')) {
			  text = "WRITING MATH SYMBOLS IS INCORRECT";
			  area.value=text;
			  text_correct = false;
			}
			if (bracket_num !=0) {
			  text = "BRACKETS ARE INCORRECT";
			  area.value=text;
			  text_correct = false;
			}
	
			 //Польская нотация
		function Prior(x) {
		if (x == '^')return 3;	
		if ((x == '*')||(x == '/')) return 2;
		if ((x == '+')||(x == '-')) return 1;
		if ((x == '(')||(x == ')')) return 0;
		else return 0;
		}

			var stroka = [];
			var stack = [];
			var cur = 0;
			
			for (var i = 0; i < text.length; i++) {
			
			if (text[i] >= '0' && text[i] <= '9' || text[i] >= 'a' && text[i] <= 'z' || text[i] >= 'A' && text[i] <= 'Z')
			  stroka.push(text[i]);
			  
			if (text[i] =='(')
			  stack.push(text[i]);

			if (text[i] ==')') {
			 while (stack[stack.length-1]!='(') {
			  cur = stack.pop();
			  stroka.push(cur);
			 }
			 stack.pop();//удалили откр. скобку
			}
			
			if (text[i] == '+' || text[i] == '-' || text[i] == '*' || text[i] == '/' || text[i] == '^') {
			 while(Prior(text[i]) < Prior(stack[stack.length-1])) {
			   cur = stack.pop();
			   stroka.push(cur);
			 }
			 stack.push(text[i]);
			}
			}
			
			while (stack.length !=0) {
			 cur = stack.pop();
			 stroka.push(cur);
			}
			
			if (text_correct == false) {
			area2.value = '';
			}
			else area2.value=stroka;
			
			//Построение дерева////////////////////////////////////////////////////////////
			
    //svg.selectAll('*').remove();
	//update(treeData);
	var treeData = [];
	stack = [];

	for (var i = 0; i < stroka.length; i++) {
	  if (stroka[i] >= '0' && stroka[i] <= '9' || stroka[i] >= 'a' && stroka[i] <= 'z' || stroka[i] >= 'A' && stroka[i] <= 'Z') {
		var node = {name: stroka[i], children:[]};
		stack.push(node);
	  }
	  if (stroka[i] == '+' || stroka[i] == '-' || stroka[i] == '*' || stroka[i] == '/' || stroka[i] == '^') {
		var node2 = stack.pop();
		var node1 = stack.pop();
		var node_root = {name: stroka[i], children:[]};
		node_root.children.push(node1);
		node_root.children.push(node2);
		stack.push(node_root);
	  }
	}

	var node_tree = stack.pop();
	
	d3.select("svg").remove();
	if (text_correct == false) {
	  treeData = [];
	}
	else treeData[0] = node_tree;
	 
		
	// ************** Generate the tree diagram	 *****************
	var margin = {top: 40, right: 120, bottom: 20, left: 120},
		width = 960 - margin.right - margin.left,
		height = 500 - margin.top - margin.bottom;
		
	var i = 0;
	 
	var tree = d3.layout.tree()
		.size([height, width]);
	 
	var diagonal = d3.svg.diagonal()
		.projection(function(d) { return [d.x, d.y]; });
	 
	var svg = d3.select("body").append("svg")
		.attr("width", width + margin.right + margin.left)
		.attr("height", height + margin.top + margin.bottom)
	  .append("g")
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	 
	root = treeData[0];
	  
	update(root);
	 
	function update(source) {
	 
	  // Compute the new tree layout.
	  var nodes = tree.nodes(root).reverse(),
		  links = tree.links(nodes);
	 
	  // Normalize for fixed-depth.
	  nodes.forEach(function(d) { d.y = d.depth * 100; });
	 
	  // Declare the nodes…
	  var node = svg.selectAll("g.node")
		  .data(nodes, function(d) { return d.id || (d.id = ++i); });
	 
	  // Enter the nodes.
	  var nodeEnter = node.enter().append("g")
		  .attr("class", "node")
		  .attr("transform", function(d) { 
			  return "translate(" + d.x + "," + d.y + ")"; });
	 
	  nodeEnter.append("circle")
		  .attr("r", 10)
		  .style("fill", "#fff");
	 
	  nodeEnter.append("text")
		  .attr("y", function(d) { 
			  return d.children || d._children ? -18 : 18; })
		  .attr("dy", ".35em")
		  .attr("text-anchor", "middle")
		  .text(function(d) { return d.name; })
		  .style("fill-opacity", 1);
	 
	  // Declare the links…
	  var link = svg.selectAll("path.link")
		  .data(links, function(d) { return d.target.id; });
	 
	  // Enter the links.
	  link.enter().insert("path", "g")
		  .attr("class", "link")
		  .attr("d", diagonal);
	 
	}
	}
	doIt();

	</script>
	</body>
	</html>
